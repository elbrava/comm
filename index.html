<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>cannon.js - RigidVehicle</title>
    <script src="./js/OpenSimplexNoise.js"></script>
    <link rel="stylesheet" href="css/style.css" type="text/css" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
  </head>
  <body>
    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.122.0/build/three.module.js";
      import * as CANNON from "./dist/cannon-es.js";
      import { Demo } from "./js/Demo.js";
      import { bodyToMesh } from "./js/three-conversion-utils.js";

      const demo = new Demo();
     
      function setupWorld(demo) {
        const world = demo.getWorld();
        world.gravity.set(0, -30, 0);

        // Sweep and prune broadphase
        world.broadphase = new CANNON.SAPBroadphase(world);

        // Adjust the global friction
        world.defaultContactMaterial.friction = 0.2;

        return world;
      }

      let mouse = true;
      function clamp(x, a, b) {
        return Math.min(Math.max(x, a), b);
      }

      class ThirdPersonCamera {
        constructor(params) {
          this._params = params;
          this._camera = params.camera;

          this._currentPosition = new THREE.Vector3();
          this._currentLookat = new THREE.Vector3();
        }
        _CalculateIdealOffset() {
          const idealOffset = new THREE.Vector3(0, 40, -60);
          let bp = body.position;
          let bq = body.quaternion;
          idealOffset.applyQuaternion(
            new THREE.Quaternion(bq.x, bq.y, bq.z, bq.w)
          );

          idealOffset.add(Vector3_Vec3(body.position));

          return idealOffset;
        }

        _CalculateIdealLookat() {
          const idealLookat = new THREE.Vector3(0, 10, 50);
          let bp = body.position;
          let bq = body.quaternion;
          idealLookat.applyQuaternion(
            new THREE.Quaternion(bq.x, bq.y, bq.z, bq.w)
          );
          idealLookat.add(Vector3_Vec3(body.position));
          return idealLookat;
        }

        Update(timeElapsed) {
          const idealOffset = this._CalculateIdealOffset();
          const idealLookat = this._CalculateIdealLookat();

          // const t = 0.05;
          // const t = 4.0 * timeElapsed;
          const t = 1.0 - Math.pow(0.001, timeElapsed);

          this._currentPosition.lerp(idealOffset, t);
          this._currentLookat.lerp(idealLookat, t);

          this._camera.position.copy(this._currentPosition);
          this._camera.lookAt(this._currentLookat);
        }
      }

      class BasicCharacterController {
        constructor(params) {
          this._Init(params);
        }

        _Init(params) {
          this._params = params;
          this.phi_ = 0;
          this.phiSpeed_ = 8;
          this.theta_ = 0;
          this.thetaSpeed_ = 5;
          this._decceleration = new THREE.Vector3(-0.0005, -0.0001, -5.0);
          this._acceleration = new THREE.Vector3(1, 0.25, 50.0);
          this._velocity = new THREE.Vector3(0, 0, 0);
          this.qq = new THREE.Quaternion();
          this._animations = {};
          this._input = new BasicCharacterControllerInput();
          //this._LoadModels();
        }
        updateRotation_(timeElapsedS) {
          const xh = mousex / window.innerWidth;
          const yh = mousey / window.innerHeight;

          this.phi_ += -xh * this.phiSpeed_;
          this.theta_ = clamp(
            this.theta_ + -yh * this.thetaSpeed_,
            -Math.PI / 3,
            Math.PI / 3
          );

          const qx = new THREE.Quaternion();
          qx.setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.phi_);
          const qz = new THREE.Quaternion();
          qz.setFromAxisAngle(new THREE.Vector3(1, 0, 0), this.theta_);

          const q = new THREE.Quaternion();
          q.multiply(qx);
          //q.multiply(qz);
          //this.qq.copy(new THREE.Quaternion(this.qq.x+q.x,this.qq.y+q.y,this.qq.z+q.z,this.qq.w+q.w) )
          this.qq.copy(q)
        }

        Update(timeInSeconds) {
          body.position=new CANNON.Vec3(0,100,0)
          sphere.position.set(
            body.position.x,
            body.position.y,
            body.position.z
          );
          sphere.quaternion.set(
            body.quaternion.x,
            body.quaternion.y,
            body.quaternion.z,
            body.quaternion.w
          );

          this._target = sphere;
          console.log(sphere);
          console.log(body);
          this.updateRotation_(timeInSeconds);
          mousex = 0;
          mousey = 0;

          if (!this._target) {
            return;
          }
         
          const velocity = this._velocity;
          const frameDecceleration = new THREE.Vector3(
            velocity.x * this._decceleration.x,
            velocity.y * this._decceleration.y,
            velocity.z * this._decceleration.z
          );
          console.log(velocity,frameDecceleration)
          frameDecceleration.multiplyScalar(timeInSeconds);
          frameDecceleration.z =
            Math.sign(frameDecceleration.z) *
            Math.min(Math.abs(frameDecceleration.z), Math.abs(velocity.z));
          console.log(velocity,frameDecceleration)
          velocity.add(frameDecceleration);
          console.log(velocity)

          const controlObject = this._target;
          const _Q = new THREE.Quaternion();
          const _A = new THREE.Vector3();

          if (mouse) {
            controlObject.quaternion.copy(this.qq);
          }

          const _R = controlObject.quaternion.clone();

          const acc = this._acceleration.clone();
          if (this._input._keys.shift) {
            acc.multiplyScalar(2.0);
          }

          if (this._input._keys.forward) {
            velocity.z += acc.z * timeInSeconds;
          }
          if (this._input._keys.backward) {
            velocity.z -= acc.z * timeInSeconds;
          }

          if (this._input._keys.left) {
            _A.set(0, 1, 0);
            _Q.setFromAxisAngle(
              _A,
              4.0 * Math.PI * timeInSeconds * this._acceleration.y
            );
            _R.multiply(_Q);
          }
          if (this._input._keys.right) {
            _A.set(0, 1, 0);
            _Q.setFromAxisAngle(
              _A,
              4.0 * -Math.PI * timeInSeconds * this._acceleration.y
            );
            _R.multiply(_Q);
          }
          controlObject.quaternion.copy(_R);

          const oldPosition = new THREE.Vector3();
          oldPosition.copy(controlObject.position);

          const forward = new THREE.Vector3(0, 0, 1);
          forward.normalize();
          forward.applyQuaternion(controlObject.quaternion);

          if (mouse) {
            forward.applyQuaternion(this.qq);
          }
          console.log(velocity)
          console.log(oldPosition)
          console.log(forward)

          const sideways = new THREE.Vector3(1, 0, 0);
          sideways.applyQuaternion(controlObject.quaternion);

          sideways.normalize();

          sideways.multiplyScalar(velocity.x * timeInSeconds);
          forward.multiplyScalar(velocity.z * timeInSeconds);

          controlObject.position.add(forward);
          controlObject.position.add(sideways);

          oldPosition.copy(controlObject.position);
          let bp = body.position;
          let co = controlObject.position;
          let change = new CANNON.Vec3(
            bp.x - co.x,
            bp.y - co.y,
            bp.z - co.z
          ).scale(1 / timeInSeconds);
          body.velocity.set(
            change.x + body.velocity.x,
            change.y + body.velocity.y,
            change.y + body.velocity.y
          );
        }
      }

      class BasicCharacterControllerInput {
        constructor() {
          this._Init();
        }

        _Init() {
          this._keys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            space: false,
            shift: false,
          };
          document.addEventListener(
            "keydown",
            (e) => this._onKeyDown(e),
            false
          );
          document.addEventListener("keyup", (e) => this._onKeyUp(e), false);
          document.addEventListener("mousemove", (e) => this._mouse(e), false);
        }

        _onKeyDown(event) {
          switch (event.keyCode) {
            case 87: // w
              this._keys.forward = true;
              break;
            case 65: // a
              this._keys.left = true;
              break;
            case 83: // s
              this._keys.backward = true;
              break;
            case 68: // d
              this._keys.right = true;
              break;
            case 32: // SPACE
              this._keys.space = true;
              break;
            case 16: // SHIFT
              this._keys.shift = true;
              break;
          }
        }

        _onKeyUp(event) {
          switch (event.keyCode) {
            case 87: // w
              this._keys.forward = false;
              break;
            case 65: // a
              this._keys.left = false;
              break;
            case 83: // s
              this._keys.backward = false;
              break;
            case 68: // d
              this._keys.right = false;
              break;
            case 32: // SPACE
              this._keys.space = false;
              break;
            case 16: // SHIFT
              this._keys.shift = false;
              break;
            case 84:
              mouse = !mouse;
          }
        }

        _mouse(event) {
          mousex = event.movementX;
          mousey = event.movementY;
        }
      }

      function step(t) {
        let te = t * 0.001;

        if (controls) {
          controls.Update(te);
        }

        thirdPersonCamera.Update(te);
      }
      function _step() {
        requestAnimationFrame((t) => {
          if (prev === null) {
            prev = t;
          }

          _step();
          step(t - prev);
          prev = t;
        });
      }

      function threeps() {
        const params = {
          camera: demo.camera,
          scene: demo.scene,
        };
        controls = new BasicCharacterController(params);

        thirdPersonCamera = new ThirdPersonCamera({
          camera: demo.camera,
          target: body,
        });
        _step();
      }

      function Vector3_Vec3(t) {
        let res = new THREE.Vector3(t.x, t.y, t.z);
        console.log(res);
        return res;
      }
      function Vec3_Vector3(t) {
        console.log(t);
        let re = new CANNON.Vec3(t.x, t.y, t.z);

        return re;
      }

      // Build the car chassis
      const wheelShape = new CANNON.Sphere(1.5);
      const wheelMaterial = new CANNON.Material("wheel");
      const radius = 10;
      let noise = new OpenSimplexNoise(7);
      const mass = 2;
      const strength = 500;
      const dt = 1 / 60;
      const damping = 0.5;
      let mousex;
      let controls;
      let thirdPersonCamera;
      let mousey;
      const geometry = new THREE.SphereGeometry(radius, 32, 16);
      const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
      const sphere = new THREE.Mesh(geometry, material);


      let prev;
      const shape = new CANNON.Sphere(radius);
      const body = new CANNON.Body({ mass, material: wheelMaterial });

      // Add impulse to the body center
      demo.addScene("Car", () => {
        const world = setupWorld(demo);

        body.position = new CANNON.Vec3(0, 100, 0);
        body.addShape(shape);
        body.linearDamping = damping;
        body.angularDamping = damping;
        world.addBody(body);
        demo.addVisual(body);
        let ma = 0.01;
        // Add the ground
        const sizeX = 300;
        const sizeZ = sizeX;
        const matrix = [];
        for (let i = 0; i < sizeX; i++) {
          matrix.push([]);
          for (let j = 0; j < sizeZ; j++) {
            if (i === 0 || i === sizeX - 1 || j === 0 || j === sizeZ - 1) {
              const height = 6;
              matrix[i].push(height);
              continue;
            }

            const height = Math.abs(noise.noise2D(i * ma, j * ma) * 56);
            matrix[i].push(height);
          }
        }

        const groundMaterial = new CANNON.Material("ground");
        const heightfieldShape = new CANNON.Heightfield(matrix, {
          elementSize: 300 / sizeX,
        });
        const heightfieldBody = new CANNON.Body({
          mass: 0,
          material: groundMaterial,
        });
        heightfieldBody.addShape(heightfieldShape);
        heightfieldBody.position.set(
          (-(sizeX - 1) * heightfieldShape.elementSize) / 2,
          -15,
          ((sizeZ - 1) * heightfieldShape.elementSize) / 2
        );
        heightfieldBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(heightfieldBody);
        demo.addVisual(heightfieldBody);

        // Define interactions between wheels and ground
        const wheel_ground = new CANNON.ContactMaterial(
          wheelMaterial,
          groundMaterial,
          {
            friction: 0.3,
            restitution: 0,
            contactEquationStiffness: 1000,
          }
        );
        world.addContactMaterial(wheel_ground);
        console.log(body.position);
        threeps();
        // Keybindings
        // Add force on keydown
        /*document.addEventListener("keydown", (event) => {
          const maxSteerVal = Math.PI / 8;
          const speed = 7;
          const rot = 1;
          const maxForce = 100;

          switch (event.key) {
            case "w":
            case "ArrowUp":
              body.velocity.z -= speed;

              break;

            case "s":
            case "ArrowDown":
              body.velocity.z += speed;

              break;

            case "a":
            case "ArrowLeft":
              body.velocity.x -= speed;

              break;

            case "d":
            case "ArrowRight":
              body.velocity.x += speed;
              break;
          }
        });

      */
      });

      demo.start();
    </script>
  </body>
</html>
