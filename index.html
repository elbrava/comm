<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>cannon.js - RigidVehicle</title>
    <script src="./js/OpenSimplexNoise.js"></script>
    <link rel="stylesheet" href="css/style.css" type="text/css" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
  </head>
  <body>
    <script type="module">
      import * as THREE from "https://unpkg.com/three@0.122.0/build/three.module.js";
      import * as CANNON from "./dist/cannon-es.js";
      import { Demo } from "./js/Demo.js";
      import { bodyToMesh } from './js/three-conversion-utils.js'

      const demo = new Demo();
      function Vector3_Vec3(t){
        let res=new THREE.Vector3(t.x,t.y,t.z)
        return res

      }
      function Vec3_Vector3(t){
        console.log(t)
        let re=new CANNON.Vec3(t.x,t.y,t.z)
        console.log(re)
        return re
      }

      // Build the car chassis
      const wheelShape = new CANNON.Sphere(1.5);
      const wheelMaterial = new CANNON.Material("wheel");
      const radius = 10;
      let noise = new OpenSimplexNoise(7);
      const mass = 2;
      const strength = 500;
      const dt = 1 / 60;
      const damping = 0.5;
      let mousex;
      let controls;
      let thirdPersonCamera;
      let mousey;
      
      let prev;
      const shape = new CANNON.Sphere(radius);
      const body = new CANNON.Body({ mass, material: wheelMaterial });

      // Add impulse to the body center
      demo.addScene("Car", () => {
        const world = setupWorld(demo);

        body.position.y = 100;
        body.addShape(shape);
        body.linearDamping = damping;
        body.angularDamping = damping;
        world.addBody(body);
        demo.addVisual(body);
        let ma = 0.01;
        // Add the ground
        const sizeX = 300;
        const sizeZ = sizeX;
        const matrix = [];
        for (let i = 0; i < sizeX; i++) {
          matrix.push([]);
          for (let j = 0; j < sizeZ; j++) {
            if (i === 0 || i === sizeX - 1 || j === 0 || j === sizeZ - 1) {
              const height = 6;
              matrix[i].push(height);
              continue;
            }

            const height = Math.abs(noise.noise2D(i * ma, j * ma) * 56);
            matrix[i].push(height);
          }
        }

        const groundMaterial = new CANNON.Material("ground");
        const heightfieldShape = new CANNON.Heightfield(matrix, {
          elementSize: 300 / sizeX,
        });
        const heightfieldBody = new CANNON.Body({
          mass: 0,
          material: groundMaterial,
        });
        heightfieldBody.addShape(heightfieldShape);
        heightfieldBody.position.set(
          (-(sizeX - 1) * heightfieldShape.elementSize) / 2,
          -15,
          ((sizeZ - 1) * heightfieldShape.elementSize) / 2
        );
        heightfieldBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
        world.addBody(heightfieldBody);
        demo.addVisual(heightfieldBody);

        // Define interactions between wheels and ground
        const wheel_ground = new CANNON.ContactMaterial(
          wheelMaterial,
          groundMaterial,
          {
            friction: 0.3,
            restitution: 0,
            contactEquationStiffness: 1000,
          }
        );
        world.addContactMaterial(wheel_ground);

        // Keybindings
        // Add force on keydown
        /*document.addEventListener("keydown", (event) => {
          const maxSteerVal = Math.PI / 8;
          const speed = 7;
          const rot = 1;
          const maxForce = 100;

          switch (event.key) {
            case "w":
            case "ArrowUp":
              body.velocity.z -= speed;

              break;

            case "s":
            case "ArrowDown":
              body.velocity.z += speed;

              break;

            case "a":
            case "ArrowLeft":
              body.velocity.x -= speed;

              break;

            case "d":
            case "ArrowRight":
              body.velocity.x += speed;
              break;
          }
        });

      */
      });

      demo.start();

      function setupWorld(demo) {
        const world = demo.getWorld();
        world.gravity.set(0, -30, 0);

        // Sweep and prune broadphase
        world.broadphase = new CANNON.SAPBroadphase(world);

        // Adjust the global friction
        world.defaultContactMaterial.friction = 0.2;

        return world;
      }

      class BasicCharacterController {
        constructor(params) {
          this._Init(params);
        }

        _Init(params) {
          this._params = params;
          this._decceleration = new THREE.Vector3(-0.0005, -0.0001, -5.0);
          this._acceleration = new THREE.Vector3(1, 0.25, 50.0);
          this._velocity = new THREE.Vector3(0, 0, 0);
          this._position = new THREE.Vector3();
        
          this._input = new BasicCharacterControllerInput();
          let material=new THREE.MeshBasicMaterial({ color: 0x00ff00})
          this._target=body
          console.log(this._target)

        }
        get Position() {
          return this._position;
        }

        get Rotation() {
          if (!this._target) {
            return new THREE.Quaternion();
          }
          return this._target.quaternion;
        }

        Update(timeInSeconds) {
          const velocity = this._velocity.clone();
          
          const frameDecceleration = new THREE.Vector3(
            velocity.x * this._decceleration.x,
            velocity.y * this._decceleration.y,
            velocity.z * this._decceleration.z
          );
          
          frameDecceleration.multiplyScalar(timeInSeconds);
          frameDecceleration.z =
            Math.sign(frameDecceleration.z) *
            Math.min(Math.abs(frameDecceleration.z), Math.abs(velocity.z));

          velocity.add(frameDecceleration);

          const controlObject = body;
          const _Q = new THREE.Quaternion();
          const _A = new THREE.Vector3();
          const _R = controlObject.quaternion.clone();
          
          const acc = this._acceleration.clone();
          if (this._input._keys.shift) {
            acc.multiplyScalar(2.0);
          }

          if (this._input._keys.forward) {
            velocity.z += acc.z * timeInSeconds;
          }
          if (this._input._keys.backward) {
            velocity.z -= acc.z * timeInSeconds;
          }
          if (this._input._keys.left) {
            _A.set(0, 1, 0);
            _Q.setFromAxisAngle(
              _A,
              4.0 * Math.PI * timeInSeconds * this._acceleration.y
            );
            _R.multiply(_Q);
          }
          if (this._input._keys.right) {
            _A.set(0, 1, 0);
            _Q.setFromAxisAngle(
              _A,
              4.0 * -Math.PI * timeInSeconds * this._acceleration.y
            );
            _R.multiply(_Q);
          }

          controlObject.quaternion.copy(_R);

          const oldPosition = new THREE.Vector3();
          oldPosition.copy(Vector3_Vec3(controlObject.position));

          const forward = new THREE.Vector3(0, 0, 1);
          forward.applyQuaternion(new THREE.Quaternion(controlObject.quaternion.x,controlObject.quaternion.y,controlObject.quaternion.z,controlObject.quaternion.w));
          forward.normalize();

          const sideways = new THREE.Vector3(1, 0, 0);
          
          sideways.applyQuaternion(new THREE.Quaternion(controlObject.quaternion.x,controlObject.quaternion.y,controlObject.quaternion.z,controlObject.quaternion.w));
          sideways.normalize();


          sideways.multiplyScalar(velocity.x * timeInSeconds);
          forward.multiplyScalar(velocity.z * timeInSeconds);
          


          controlObject.position=Vec3_Vector3( Vector3_Vec3( controlObject.position).add(forward));
          console.log(controlObject.position)
          controlObject.position=Vec3_Vector3( Vector3_Vec3(  controlObject.position).add(sideways))

          this._position.copy(Vector3_Vec3(controlObject.position));

        }
      }

      class BasicCharacterControllerInput {
        constructor() {
          this._Init();
        }

        _Init() {
          this._keys = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            space: false,
            shift: false,
          };
          document.addEventListener(
            "keydown",
            (e) => this._onKeyDown(e),
            false
          );
          document.addEventListener("keyup", (e) => this._onKeyUp(e), false);
        }

        _onKeyDown(event) {
          switch (event.keyCode) {
            case 87: // w
              this._keys.forward = true;
              break;
            case 65: // a
              this._keys.left = true;
              break;
            case 83: // s
              this._keys.backward = true;
              break;
            case 68: // d
              this._keys.right = true;
              break;
            case 32: // SPACE
              this._keys.space = true;
              break;
            case 16: // SHIFT
              this._keys.shift = true;
              break;
          }
        }

        _onKeyUp(event) {
          switch (event.keyCode) {
            case 87: // w
              this._keys.forward = false;
              break;
            case 65: // a
              this._keys.left = false;
              break;
            case 83: // s
              this._keys.backward = false;
              break;
            case 68: // d
              this._keys.right = false;
              break;
            case 32: // SPACE
              this._keys.space = false;
              break;
            case 16: // SHIFT
              this._keys.shift = false;
              break;
          }
        }
      }

      class ThirdPersonCamera {
        constructor(params) {
          this._params = params;
          this._camera = params.camera;

          this._currentPosition = new THREE.Vector3();
          this._currentLookat = new THREE.Vector3();
        }

        _CalculateIdealOffset() {
          const idealOffset = new THREE.Vector3(-15, 20, -30);
          idealOffset.applyQuaternion(this._params.target.Rotation);
          idealOffset.add(this._params.target.Position);
          return idealOffset;
        }

        _CalculateIdealLookat() { 
          const idealLookat = new THREE.Vector3(0, 10, 50);
          idealLookat.applyQuaternion(this._params.target.Rotation);
          idealLookat.add(this._params.target.Position);
          return idealLookat;
        }

        Update(timeElapsed) {
          const idealOffset = this._CalculateIdealOffset();
          const idealLookat = this._CalculateIdealLookat();

          // const t = 0.05;
          // const t = 4.0 * timeElapsed;
          const t = 1.0 - Math.pow(0.001, timeElapsed);

          this._currentPosition.lerp(idealOffset, t);
          this._currentLookat.lerp(idealLookat, t);

          this._camera.position.copy(this._currentPosition);
          this._camera.lookAt(this._currentLookat);
          
          
        }
      }
      function step(t) {
        let te = t * 0.001;
   

        if (controls) {
          controls.Update(te);
        }

        thirdPersonCamera.Update(te);
      }
      function _step() {
        requestAnimationFrame((t) => {
          if (prev === null) {
            prev = t;
          }

          _step();
          step(t - prev);
          prev = t;
        });
      }

      function threeps() {
        const params = {
          camera: demo.camera,
          scene: demo.scene,
        };
        controls = new BasicCharacterController(params);

        thirdPersonCamera = new ThirdPersonCamera({
          camera: demo.camera,
          target: controls,
        });
        _step();
      }
      threeps();
    </script>
  </body>
</html>
